# mc_vs_redis

Redis более мощный, более популярный и лучше поддерживаемый, чем memcached. Memcached может делать только небольшую часть того, что может делать Redis. Redis лучше даже там, где их функции перекрываются.

Для чего-нибудь нового используйте Redis.

Memcached vs Redis: Прямое сравнение
Оба инструмента являются мощными, быстрыми хранилищами данных в памяти, которые полезны в качестве кэша. И то, и другое может помочь ускорить работу вашего приложения, кэшируя результаты базы данных, фрагменты HTML или что-либо еще, что может быть дорогостоящим для создания.

Вопросы для рассмотрения
Когда они используются для того же самого, вот как они сравниваются, используя исходные вопросы "Точки для рассмотрения":

Скорость чтения/записи: И то, и другое чрезвычайно быстро. Бенчмарки различаются по рабочей нагрузке, версиям и многим другим факторам, но обычно показывают, что redis работает так же быстро или почти так же быстро, как memcached. Я рекомендую redis, но не потому, что memcached работает медленно. Это не.
Использование памяти: Redis лучше.
memcached: Вы указываете размер кэша, и по мере вставки элементов демон быстро растет до немного большего размера. На самом деле нет никакого способа вернуть себе это пространство, кроме перезапуска memcached. Все ваши ключи могут быть просрочены, вы можете очистить базу данных, и она все равно будет использовать полный кусок оперативной памяти, с которым вы ее настроили.
redis: Установка максимального размера зависит только от вас. Redis никогда не будет использовать больше, чем нужно, и вернет вам память, которую он больше не использует.
Я сохранил 100 000 ~2 КБ строк (~200 МБ) случайных предложений в обоих. Использование оперативной памяти Memcached выросло до ~225 МБ. Использование оперативной памяти Redis выросло до ~228 МБ. После промывки обоих redis упал до ~29 МБ, а memcached остался на уровне ~225 МБ. Они одинаково эффективны в том, как они хранят данные, но только один способен восстановить их.
Сброс дискового ввода-вывода : Явный выигрыш для redis, так как он делает это по умолчанию и имеет очень настраиваемую персистентность. Memcached не имеет механизмов для сброса на диск без сторонних инструментов.
Масштабирование: и то, и другое дает вам массу возможностей, прежде чем вам понадобится больше одного экземпляра в качестве кэша. Redis включает в себя инструменты, которые помогут вам выйти за рамки этого, в то время как memcached этого не делает.
memcached
Memcached-это простой летучий кэш-сервер. Он позволяет хранить пары ключ/значение, где значение ограничено строкой размером до 1 МБ.

Он хорош в этом, но это все, что он делает. Вы можете получить доступ к этим значениям с помощью их ключа на чрезвычайно высокой скорости, часто насыщая доступную пропускную способность сети или даже памяти.

Когда вы перезапускаете memcached, ваши данные исчезают. Это прекрасно подходит для тайника. Вы не должны хранить там ничего важного.

Если вам нужна высокая производительность или высокая доступность, то доступны инструменты, продукты и услуги сторонних производителей.

редис
Redis может выполнять те же задачи, что и memcached, и может делать их лучше.

Redis также может выступать в качестве кэша. Он также может хранить пары ключ/значение. В redis они могут достигать даже 512 МБ.

Вы можете отключить настойчивость, и она тоже с радостью потеряет ваши данные при перезапуске. Если вы хотите, чтобы ваш кэш выжил, он позволяет вам сделать это. На самом деле это дефолт.

Он также очень быстр, часто ограничен пропускной способностью сети или памяти.

Если один экземпляр redis/memcached недостаточно быстродействует для вашей рабочей нагрузки, redis-это очевидный выбор. Redis включает поддержку кластера и поставляется с инструментами высокой доступности (redis-sentinel) прямо "в коробке". За последние несколько лет redis также стал явным лидером в области 3-й партии инструментов. Такие компании, как Redis Labs, Amazon и другие, предлагают множество полезных инструментов и услуг redis. Экосистема вокруг редиса намного больше. Число крупномасштабных развертываний теперь, вероятно, больше, чем для memcached.

Суперсет Redis
Redis-это больше, чем кэш. Это сервер структуры данных в памяти. Ниже вы найдете краткий обзор того, что Redis может сделать помимо простого кэша ключей/значений, такого как memcached. Большинство функций redis - это то, что memcached не может сделать.

Документация
Redis лучше документирован, чем memcached. Хотя это может быть субъективно, это кажется все более и более истинным все время.

redis.io это фантастический легко ориентируемый ресурс. Он позволяет вам попробовать redis в браузере и даже дает вам живые интерактивные примеры с каждой командой в документах.

Теперь есть 2 раза больше результатов stackoverflow для redis, чем memcached. в 2 раза больше результатов Google. Более доступные примеры на большем количестве языков. Более активное развитие. Более активное развитие клиентов. Эти измерения могут не иметь большого значения по отдельности, но в сочетании они рисуют четкую картину того, что поддержка и документация redis больше и намного современнее.

Упорство
По умолчанию redis сохраняет данные на диск с помощью механизма snapshotting. Если у вас достаточно оперативной памяти, он может записать все ваши данные на диск почти без снижения производительности. Это почти бесплатно!

В режиме моментального снимка есть вероятность, что внезапный сбой может привести к небольшому количеству потерянных данных. Если вам абсолютно необходимо убедиться, что никакие данные никогда не будут потеряны, не волнуйтесь, redis тоже имеет вашу спину в режиме AOF (Append Only File). В этом режиме сохранения данные могут быть синхронизированы с диском по мере их записи. Это может снизить максимальную пропускную способность записи до той скорости, с которой может работать ваш диск, но все равно должно быть довольно быстрым.

Существует множество вариантов конфигурации для точной настройки персистентности, если вам это нужно, но значения по умолчанию очень разумны. Эти параметры позволяют легко настроить redis как безопасное, избыточное место для хранения данных. Это настоящая база данных.

Множество Типов Данных
Memcached ограничен строками, но Redis-это сервер структуры данных, который может обслуживать множество различных типов данных. Он также предоставляет команды, необходимые для максимального использования этих типов данных.

Строки (команды)
Простой текст или двоичные значения, которые могут быть размером до 512 МБ. Это единственный общий ресурс типа данных redis и memcached, хотя строки memcached ограничены 1 МБ.

Redis предоставляет вам больше инструментов для использования этого типа данных, предлагая команды для побитовых операций, манипуляций на уровне битов, поддержки приращения/декремента с плавающей точкой, запросов диапазона и операций с несколькими ключами. Memcached не поддерживает ничего из этого.

Строки полезны для всех видов случаев использования, поэтому memcached довольно полезен только с этим типом данных.

Хэши (команды)
Хэши-это своего рода хранилище ключевых значений в хранилище ключевых значений. Они сопоставляются между строковыми полями и строковыми значениями. Карты полей->значений, использующие хэш, немного более эффективны в пространстве, чем карты ключей->>значений, использующие обычные строки.

Хэши полезны как пространство имен или когда вы хотите логически сгруппировать много ключей. С помощью хэша вы можете эффективно захватить всех членов, истечь срок действия всех членов вместе, удалить всех членов вместе и т. Д. Отлично подходит для любого случая использования, когда у вас есть несколько пар ключ/значение, которые нужно сгруппировать.

Одним из примеров использования хэша является хранение профилей пользователей между приложениями. Хэш redis, хранящийся с идентификатором пользователя в качестве ключа, позволит вам хранить столько битов данных о пользователе, сколько необходимо, сохраняя их под одним ключом. Преимущество использования хэша вместо сериализации профиля в строку заключается в том, что вы можете заставить разные приложения читать/записывать разные поля в профиле пользователя, не беспокоясь о том, что одно приложение переопределяет изменения, внесенные другими (что может произойти, если вы сериализуете устаревшие данные).

Списки (команды)
Списки Redis-это упорядоченные коллекции строк. Они оптимизированы для вставки, чтения или удаления значений из верхней или нижней части списка (он же: слева или справа).

Redis предоставляет множество команд для использования списков, включая команды для push/pop элементов, push/pop между списками, усечения списков, выполнения запросов диапазона и т. Д.

Списки делают большие прочные, атомарные очереди. Они отлично подходят для очередей заданий, журналов, буферов и многих других вариантов использования.

Наборы (команды)
Наборы-это неупорядоченные коллекции уникальных значений. Они оптимизированы, чтобы вы могли быстро проверить, находится ли значение в наборе, быстро добавлять/удалять значения и измерять перекрытие с другими наборами.

Они отлично подходят для таких вещей, как списки контроля доступа, уникальные трекеры посетителей и многое другое. Большинство языков программирования имеют нечто подобное (обычно называемое Набором). Вот так, только распределено.

Redis предоставляет несколько команд для управления наборами. Очевидные из них, такие как добавление, удаление и проверка набора, присутствуют. Так же как и менее очевидные команды, такие как выскакивание/чтение случайного элемента и команды для выполнения союзов и пересечений с другими наборами.

Сортированные Наборы (команды)
Сортированные наборы также являются коллекциями уникальных значений. Эти, как следует из названия, упорядочены. Они упорядочены по партитуре, затем лексикографически.

Этот тип данных оптимизирован для быстрого поиска по баллам. Получение самого высокого, самого низкого или любого диапазона значений между ними происходит чрезвычайно быстро.

Если вы добавите пользователей в сортированный набор вместе с их высоким баллом, то получите идеальную доску лидеров. Как только появятся новые высокие баллы, просто добавьте их в набор снова с их высоким баллом, и он переупорядочит вашу таблицу лидеров. Также отлично подходит для отслеживания последнего посещения пользователей и кто активен в вашем приложении.

Хранение значений с одинаковым счетом приводит к тому, что они упорядочиваются лексикографически (например, в алфавитном порядке). Это может быть полезно для таких вещей, как функции автозаполнения.

Многие из отсортированных команд набора похожи на команды для наборов, иногда с дополнительным параметром score. Также включены команды для управления баллами и запроса по баллам.

Гео
Redis имеет несколько команд для хранения, извлечения и измерения географических данных. Это включает запросы радиуса и измерение расстояний между точками.

Технически географические данные в redis хранятся в отсортированных наборах, так что это не совсем отдельный тип данных. Это скорее расширение поверх отсортированных наборов.

Bitmap и HyperLogLog
Как и geo, это не совсем отдельные типы данных. Это команды, которые позволяют обрабатывать строковые данные так, как если бы это было либо растровое изображение, либо гиперлог.

Растровые изображения-это то, для чего предназначены операторы битового уровня, на которые я ссылалсяStrings. Этот тип данных был основным строительным блоком для недавнего совместного арт-проекта reddit: r/Place.

HyperLogLog позволяет использовать постоянный чрезвычайно малый объем пространства для подсчета почти неограниченных уникальных значений с потрясающей точностью. Используя только ~16 КБ, вы могли бы эффективно подсчитать количество уникальных посетителей вашего сайта, даже если это число исчисляется миллионами.

Транзакции и атомарность
Команды в redis являются атомарными, то есть вы можете быть уверены, что, как только вы запишете значение в redis, это значение будет видно всем клиентам, подключенным к redis. Нет никакого ожидания, пока это значение распространится. Технически memcached также является атомарным, но с redis, добавляющим всю эту функциональность за пределами memcached, стоит отметить и несколько впечатляет, что все эти дополнительные типы данных и функции также являются атомарными.

Хотя это не совсем то же самое, что транзакции в реляционных базах данных, redis также имеет транзакции, которые используют "оптимистическую блокировку" (WATCH/MULTI/EXEC).

Конвейеризация
Redis предоставляет функцию под названием "конвейеризация". Если у вас есть много команд redis, которые вы хотите выполнить, вы можете использовать конвейерную передачу, чтобы отправить их в redis все сразу, а не по одному.

Обычно при выполнении команды redis или memcached каждая команда представляет собой отдельный цикл запроса/ответа. С конвейеризацией redis может буферизировать несколько команд и выполнять их все одновременно, отвечая всеми ответами на все ваши команды в одном ответе.

Это может позволить вам достичь еще большей пропускной способности при массовом импорте или других действиях, которые включают много команд.

Паб/Саб
Redis имеет команды , посвященные функциональности pub/sub, что позволяет redis выступать в качестве высокоскоростного вещателя сообщений. Это позволяет одному клиенту публиковать сообщения многим другим клиентам, подключенным к каналу.

Redis делает pub/sub так же хорошо, как и почти любой инструмент. Выделенные брокеры сообщений, такие как RabbitMQ, могут иметь преимущества в определенных областях, но тот факт, что один и тот же сервер также может дать вам постоянные длительные очереди и другие структуры данных, которые, вероятно, понадобятся вашим рабочим нагрузкам pub/sub, Redis часто оказывается лучшим и самым простым инструментом для этой работы.

Lua Scripting
Вы можете думать о lua-скриптах, таких как собственный SQL redis или хранимые процедуры. Это и больше, и меньше, но аналогия в основном работает.

Возможно, у вас есть сложные вычисления, которые вы хотите выполнить в redis. Возможно, вы не можете позволить себе откатывать транзакции и нуждаетесь в гарантиях, что каждый шаг сложного процесса будет происходить атомарно. Эти и многие другие проблемы можно решить с помощью сценариев lua.

Весь сценарий выполняется атомарно, поэтому, если вы можете вписать свою логику в сценарий lua, вы часто можете избежать возни с оптимистичными транзакциями блокировки.

Пересчет
Как уже упоминалось выше, redis включает в себя встроенную поддержку кластеризации и поставляется в комплекте с собственным инструментом высокой доступности под названием redis-sentinel.

Вывод
Без колебаний я бы рекомендовал redis over memcached для любых новых проектов или существующих проектов, которые еще не используют memcached.

Выше может показаться, что мне не нравится memcached. Напротив, это мощный, простой, стабильный, зрелый и закаленный инструмент. Есть даже некоторые случаи использования, когда это немного быстрее, чем redis. Я люблю memcached. Я просто не думаю, что это имеет смысл для будущего развития.

Redis делает все, что делает memcached, а часто и лучше. Любое преимущество в производительности memcached является незначительным и зависит от рабочей нагрузки. Существуют также рабочие нагрузки, для которых redis будет работать быстрее, и гораздо больше рабочих нагрузок, которые redis может выполнять, а memcached просто не может. Крошечные различия в производительности кажутся незначительными перед лицом гигантской пропасти в функциональности и того факта, что оба инструмента настолько быстры и эффективны, что вполне могут стать последней частью вашей инфраструктуры, о масштабировании которой вам когда-либо придется беспокоиться.

Существует только один сценарий, в котором memcached имеет больше смысла: когда memcached уже используется в качестве кэша. Если вы уже кэшируете с помощью memcached, то продолжайте использовать его, если он соответствует вашим потребностям. Скорее всего, это не стоит усилий, чтобы перейти на redis, и если вы собираетесь использовать redis только для кэширования, это может не принести достаточно пользы, чтобы стоить вашего времени. Если memcached не отвечает вашим потребностям, то вам, вероятно, следует перейти на redis. Это верно независимо от того, нужно ли вам масштабироваться за пределы memcached или вам нужна дополнительная функциональность.
